#version 430
#extension GL_ARB_bindless_texture : require
#extension GL_ARB_gpu_shader_int64 : require
//#extension GL_ARB_compute_variable_group_size : require

//layout(local_size_variable) in;
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

uniform ivec3 gridDim;

layout(binding = 0, std430) buffer voxelGridBuffer
{
    layout(rgba32f) image3D voxelGrid;
};

layout(binding = 1, std430) buffer cameraBuffer
{
    mat4 playerViewMatrix;
    mat4 playerProjMatrix;
    vec3 camPos;
};

layout(binding = 2, std430) buffer fogBuffer
{
    vec3 fogAlbedo;
    float fogAnisotropy;
    layout(rgba32f) image3D densityMap;
    float fogScatteringCoeff;
    float fogAbsorptionCoeff;
};

//TODO: generate light buffer on cpu
struct Light
{
    vec4 pos; //pos.w=0 directional, pos.w=1 point light
    vec3 col;
    float spot_cutoff; //no spotlight if cutoff=0
    vec3 spot_direction;
    float spot_exponent;
    mat4 lightSpaceMatrix;
    uint64_t shadowMap; //can be sampler2D or samplerCube
};

layout(std430, binding = LIGHTS_BINDING) restrict readonly buffer lightBuffer
{
    Light lights[];
};

vec3 getWorldPos(ivec3 voxelPos)
{
    vec3 centerOffset = 0.5f / gridDim; // for translation into center of voxel

    float m22 = playerProjMatrix[2][2];
    float m32 = playerProjMatrix[3][2];
    float n = m32 / (m22 - 1.0f); // playerCameraNear
    float f = n * (m22 - 1.0f) / (m22 + 1.0); // playerCameraFar

    vec3 uvPos = vec3(voxelPos) / gridDim + centerOffset;
    uvPos.z = (f + n - 2.0f * n * f / uvPos.z) / (f - n); // de-linearize depth

    uvPos *= 2.0f;
    uvPos -= vec3(1.0f);

    vec4 worldSpacePos = inverse(playerProjMatrix * playerViewMatrix) * vec4(uvPos, 1.0f);
    worldSpacePos.xyzw /= worldSpacePos.w; // perspective division

    return worldSpacePos.xyz;
}

float getZLayerThickness(int zLayer) 
{
    return 1.0f / float(gridDim.z); //TODO: change to exponential distribution
}

float getDensity(vec3 worldPos)
{
    float d0 = 1.0f;
    return d0 * exp(-worldPos.y * 0.1f); //TODO: sample density texture instead
}

float getPhaseFunction(float g, vec3 lightVec, vec3 viewVec) // vectors must be normalized!
{
    float cosTheta = dot(-viewVec, lightVec);
    return (1.0f / (4.0f * 3.14159265359f)) * (1.0f - g * g) / pow((1.0f + g * g - 2.0f * g * cosTheta), 1.5f);
}

vec3 getLight(int lightIndex)
{
    //TODO: evaluate actual incoming light (cutoff, occlusion, etc...)
    return lights[lightIndex].col;
}

void main()
{
    ivec3 g_ID = ivec3(gl_GlobalInvocationID);

    vec3 worldPos = getWorldPos(g_ID);

    float thickness = getZLayerThickness(g_ID.z);
    float density = getDensity(worldPos);

    float scattering = fogScatteringCoeff * density * thickness;
    float absorbtion = fogAbsorptionCoeff * density * thickness;

    vec3 viewDir = normalize(worldPos - camPos);

    vec3 lighting = vec3(0.f);

    //TODO: add sunlight and ambient to lighting?!

    for (int i = 0; i < lights.length(); ++i)
    {
        vec3 lightDir = normalize(lights[i].pos.xyz - worldPos);
        lighting += getLight(i) * getPhaseFunction(fogAnisotropy, lightDir, viewDir);
    }

    lighting *= fogAlbedo;

    vec4 outColor = vec4(lighting * scattering, scattering + absorbtion); //TODO: write this value into voxelGrid

	//if(g_ID.x <= gridDim.x && g_ID.y <= gridDim.y && g_ID.z <= gridDim.z)
	{
		imageStore(voxelGrid, g_ID, vec4(worldPos, 1.0f));//vec4(g_ID, 1.0f));
	}

}

